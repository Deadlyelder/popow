\section{Applications and Evaluation}

\ignore{
\subsection{Comparison with alternatives.}

In Table

\begin{table}
  \caption{Comparison of Sidechains Techniques ($B$ blocks in between transactions)}
  \begin{tabular}{llll}
    {\bf Technique}  & {\bf Cost}       & {\bf Rounds}    & {\bf Trust Model} \\
    Our technique    & $O(m polylog B)$ &              & \\
    PoPoW~\cite{kls} & $O(m polylog B)$ &              & \\
    Plain SPV        &   $O(B)$         & & \\
Drivechains~\cite{sztorc}& $O(1)$       &              & \\
    Federated        &     $O(1)$       &              & Centralized \\
  \end{tabular}
\end{table}

In the case of 
}



\subsection{Multi-blockchain wallets.}

One potential application of our technique is an efficient multi-cryptocurrency client.
Consider for example a merchant that wishes to accept payments in any cryptocurrency, not just the most popular ones.
A na\"ive approach would be for the merchant to simply install an SPV client for each known cryptocurrency. However, this approach would entail downloading the header chain for each cryptocurrency, and periodically (e.g., each day) syncing up by fetching any newly generated block headers.
Another alternative would be to use an online service supporting multiple currencies, such as an exchange, although this introduces reliance on a third party. Similarly, existing multi-cryptocurrency apps, such as Jaxx\footnote{\url{https://jaxx.io/}} and Coinomi\footnote{\url{https://coinomi.com/}} rely on third party networks rather than peer-to-peer networks.

\paragraph{A multi-blockchain wallet based on NiPoPoWs}
 The NiPoPoW-based client maintains a most recent $k$-stable block hash for each of its supported cryptocurrencies, initially the genesis block for each.
  Each time a payment is received, the client connects to peers on the corresponding network and asks for a NiPoPoW proof relative to the most recently stored block hash. For cryptocurrencies where payments are received very frequently, the NiPoPoW-based client might download nearly every block header, just like an ordinary SPV client; however, for cryptocurrencies used infrequently, the NiPoPoW-based client would be able to skip over many of the blocsk.

\paragraph{Simulation}
 We developed a simulation to evaluate the potential resources savings resulting from the use of a NiPoPoW-based client.
 We model the arrival of payments in each cryptocurrency as a Poisson process, and assume that the market capitalization of a cryptocurrency is a proxy for usage, i.e. in our model most payments received are Bitcoin transactions, with transactions from the remaining constituting a long tail.
 
 At the current time of writing, a total of 731 cryptocurrencies are listed on \url{https://coinmarketcap.com/}.
This list includes many defunct cryptocurrencies that are no longer functioning at all.
We narrow our focus to the 80 cryptocurrencies that have their own proof-of-work blockchains
, (i.e., no proof of stake) and that have a market cap of over USD \$100,000.
In Table~\ref{tbl:currencies} we show aggregate statistics about these 80 cryptocurrencies, grouped according to the their proof-of-work puzzle (e.g., Litecoin uses the scrypt hash function, while Bitcoin uses the SHA-256 function). The ``Size today'' column reflects the current size of all the proof-of-work headers, while ``Growth rate'' reflects the additional proof-of-work headers generated each day. Here we make the conservative assumption that the size of a block header is exactly 80 bytes, as it is in Bitcoin.
Bitcoin's 10 minute block time is relatively slow; other cryptocurrencies typically use faster block times, e.g. 12 seconds for Ethereum and 2 minutes for Litecoin. Thus while the entire chain of proof-of-work puzzles in Bitcoin today only amounts to about 40 MB, taken together, the 80 cryptocurrencies comprise nearly 10 GB of proofs-of-work, and generate nearly 10 MB more each day.

 In our simulation we choose NiPoPoW parameters based as in the previous section, with $m=6$ and $k=24$.
In Table~\ref{fig:experiment} we show the resulting bandwidth costs from simulating a period of 60 days, with varying rates of payments received.

 For the na\"ive SPV client, the total bandwidth cost is dominated by the need to fetch the entire chain of block headers, which the NiPoPoW client does not need to do. The marginal cost for na\"ive SPV depends on the number of blocks generated each day, as well as the transaction inclusion proofs associated with each payment. The NiPoPoW based client provides the most savings when the number of transactions per day is smallest, reducing the necessary bandwidth per day (not including the initial synch up) by 90\%.

\begin{table}
  \caption{Cost of header chains for all active Proof-of-Work-based cryptocurrencies (collected from \url{Coinwarz.com})}
  \label{tbl:currencies}
\small
  \begin{tabular}{l|l|l|l}
    {\bf Hash} & {\bf \# Instances} & {\bf Size today} & {\bf Growth rate}  \\
    \hline
    Scrypt  & 44  & 4.3 GB  & 5.5 MB / day \  \\
    SHA-256  & 15  & 1.4 GB  & 937.0 kB / day \  \\
    X11  & 5  & 581.1 MB  & 556.3 kB / day \  \\
    Quark  & 3  & 647.9 MB  & 518.4 kB / day \  \\
    CryptoNight  & 2  & 199.0 MB  & 115.2 kB / day \  \\
    EtHash  & 2  & 588.6 MB  & 921.6 kB / day \  \\
    Groestl  & 2  & 300.3 MB  & 184.2 kB / day \  \\
    NeoScrypt  & 2  & 310.6 MB  & 153.6 kB / day \  \\
    Equihash  & 2  & 17.7 MB  & 92.2 kB / day \  \\
    Keccak  & 1  & 161.1 MB  & 115.2 kB / day \  \\
    X13  & 1  & 30.0 MB  & 57.6 kB / day \  \\
    Lyra2REv2  & 1  & 57.4 MB  & 46.1 kB / day \  \\
    \hline
    Total  & 80   &  8.5 GB  & 9.2 MB  / day  \\
  \end{tabular}
\end{table}



\begin{table}
  \caption{Simulated bandwidth of multi-blockchain clients after two months (Averaged over 10 trials each)}
  \small
  \centering
  \begin{tabular}{@{\hspace{0.1pt}}l|l@{\hspace{3pt}}l@{\hspace{3pt}}|l@{\hspace{3pt}}l@{\hspace{3pt}}|l@{\hspace{0.1pt}}}
               & \multicolumn{2}{c|}{Naive SPV} & \multicolumn{2}{c|}{NiPoPoW} \\
    Tx/day & Total & (Per day) & Total & (Per day) & Savings \\
    \hline
    100   &  5.5 GB & (5.5 MB)   & 31.7 MB & (507.4 kB)   & 0.99 (0.91) \\
    500   &  5.5 GB & (5.7 MB)   & 68.2 MB & (1.1 MB)     & 0.99 (0.81) \\
    1000  &  5.5 GB & (6.0 MB)   & 99.1 MB & (1.6 MB)     & 0.98 (0.73) \\
    3000  &  5.6 GB & (7.0 MB)   & 192.5 MB& (3.1 MB)     & 0.97 (0.56) \\
    \end{tabular}
  \end{table}

\subsection{More Applications}

\paragraph{Catena.}
In Catena,~\cite{catena} the Bitcoin blockchain is used as an equivocation-resistant public log in which to publish commitments to SSL certificates. The Catena client prototype is based on the BitcoinJ SPV library, and therefore requires downloading the entire Bitcoin proof-of-work chain.
Catena could therefore immediately be improved by using NiPoPoWs.

First, we note that the Catena authors anticipate needing to launch a dedicated Header Relay Network~\cite{catena} to accomodate the extra bandwidth demands from new Catena clients. A variant based on NiPoPoWs could obviate this, since it eliminates the need to bootstrap new clients by transmitting the entire 40MB Bitcoin header chain.
The steady state cost of operating a Catena client depends on how frequently certificate digests are published. For example, one usage scenario cited by Catena~\cite{catena} is Keybase, a service which publishes certificate digests every 6 hours. During a 6 hour period, Bitcoin would generate 6 kilobytes of headers, whereas a NiPoPoW proof covering the same range would require less than half this size.
The  savings would increase further if Catena were implemented using any proof-of-work blockchain with more frequent blocks, such as Ethereum or Litecon.

\paragraph{Sidechains.}
Back et al.~\cite{sidechains} proposed .

An application of our technique is for sidechains.
Hash lock contract are supported by most cryptocurrency scripting languages, including Bitcoin script and the Ethereum virtual machine. Only relies on the ability to verify that a user provided input is the preimage of a given hash.


Improving on both of these works, we successfully presented PoPoWs that are
both sublinear and non-interactive.

Efficiency of PoPoWs has been explored in the blockchain community especially
around the topic of sidechains \cite{sidechains}, but to our knowledge no
concrete provably secure solution has been previously proposed.

BTCRelay~\cite{btcrelay} is an Ethereum~\cite{ethereum} smart contract written in Ethereum that acts as an SPV client for the Bitcoin blockchain.
That is, the smart contract contains rules for parsing 
This allows Ethereum smart contract to condition their behavior based on the presence of particular transactions in the Bitcoin blockchain.
Users can interact with the client to submit Bitcoin.

At the current time, Ethereum does not provide built-in support for other hashes like scrypt, or even EtHash, the basis for Ethereum's own proof of work. Ethereum could be upgraded to support such opcodes in the future. This would 


