\section{Model}

In order to study the syntax and properties of NIPoPoWs
we abstract their operation in a way that is akin to non-interactive
zero-knowledge proofs (NIZK), \cite{BFM88}. In such protocols, a prover
shares some context with a verifier (called the common reference string).
For a given predicate, the prover computes the proof string and transmits it
to the verifier. The verifier accepts or rejects the string. Given that in our
setting the predicates will be referring to an active evolving chain 
we should define them in the presence of a blockchain protocol. 
Our theoretical abstraction is based on ``backbone'' model of
\cite{backbone} that formalizes the operation of the bitcoin protocol.
We introduce the Prover and the Verifier in
the standard Backbone model as follows. The Prover will extend the functionality
of the miner node. The Verifier will be a completely new entity that can be spawned
by the environment and process a NiPoPow produced by the miner nodes running
the Prover code. 

The predicates of interest in our context are predicates on the active blockchain. 
Some of the predicates are more suitable for (succinct) proofs than others. We focus
our attention in what we call \textit{reliable} predicates; that is,
predicates which are monotonic and stable notions that we define below.  
These predicates have the
exceptional property that all honest miners share their view of them in a way
that is updated in a predictable manner, with a truth-value that persists as the
blockchain grows.  Furthermore, we are interested in \textit{succinct}
predicates, predicates which can be proven using a succinct protocol, a
protocol which requires proofs that are short in terms of the total blockchain
size. Finally, we formalize the notion of non-interactivity.

%We use this model to explore which predicates are reliable and can be proven
%succinctly.

\import{./}{algorithms/alg.backbone.tex}
\import{./}{algorithms/alg.backbone-prover.tex}
\import{./}{algorithms/alg.verifier-framework.tex}

For blockchain addressing we use the Python range notation of brackets ($[]$).
A positive number in a bracket indicates the indexed block in the blockchain,
starting from zero. A negative number indicates a block indexed from the end. A
range of two numbers separated by a $:$ indicates a subarray starting on the
left index and ending on the right index, inclusive. Omitting one of the range
indices takes it to the beginning or end of the blockchain respectively.

