\begin{proof}
    We will prove security by contradiction.  Let $m = k_1 + k_2$ and let $k =
    k(\kappa)$, $k_1 = k_1(\kappa)$ and $k_2 = k_2(\kappa)$ be polynomial
    functions of the security parameter $\kappa$.  Let $Q$ be a $k$-stable
    suffix sensitive chain predicate. Assume the NIPoPoWs construction with
    parameters $m, k$ is not secure with respect to $Q$. Then, during an
    execution at some round $r_3$, $Q(\chain)$ is defined and has the same
    value for all honest miners.  Assume the execution is typical. The verifier
    $V$ communicates with at least two provers, $\mathcal{A}$, the adversary,
    and $B$, an honest prover.  The verifier receives the proofs
    $\overline{\Pi}_\mathcal{A}, \overline{\Pi}_B$ from the adversary and the
    honest prover respectively.  Because $B$ is honest, $\overline{\Pi}_B$ will
    be a proof constructed based on an underlying blockchain $\chain_B$ which
    is the adopted blockchain of $B$ during round $r_3$. The verifier then
    outputs $\lnot Q(\chain_B)$, and so $\textsf{Verify}^Q_{m,k} = \lnot Q(\chain_B)$.
    $\textsf{maxChain}$ provides a total order among proofs.  Thus it is
    necessary that $\textsf{maxChain}(\overline{\Pi}_\mathcal{A},
    \overline{\Pi}_B)$ evaluates to true, otherwise, because $Q$ is suffix
    sensitive, $\textsf{Verify}^Q$ would have returned $Q(\chain_B)$. We will
    now show that $\textsf{maxChain}$ returning true is a negligible event.

    Let $b$ be the LCA of $\overline{\Pi}_A$ and $\overline{\Pi}_B$.  There are
    two ways in which $V$'s call to $\textsf{maxChain}$ can return true. Either
    it happens within the \textit{for} loop and so the comparison is at the
    superchain level, or it happens at the end and so the comparison is at
    level $0$. We will deal with these cases separately.

    \textbf{Case 1:} The $\textsf{maxChain}$ algorithm returned true at level
    $0$.

    This means that the \textit{for} loop was executed without the \textit{if}
    statement ever becoming true, and so $b$ is a block towards the end of
    $\chain_B$. Specifically, $\overline{\Pi}_B$ will contain all the blocks in
    $\chain_B$ after $b$. In order to cause $V$ to output a different value for
    the predicate $Q$, the adversary must present at least $k$ blocks after $b$
    which are not in $\chain_B$. This is because the predicate is $k$-stable.
    But this violates the Common Prefix property and thus occurs with
    negligible probability.

    \textbf{Case 2:} The $\textsf{maxChain}$ algorithm returned true at some
    level $\mu > 0$.

    Then $\mu$ be the highest level at which $A$ is able to present $m$ blocks
    of level $\mu$ after $b$. We will first show that the two chains after $b$
    are disjoint. Because $A$ is winning, therefore $\mu$ is the highest level
    at which any of the parties was able to present at least $m$ blocks of that
    level after $b$.  This means that at every higher level $\mu + i$ for $i >
    0$, it was true that $b$ was within the last $m$ blocks of that level.
    Therefore, $B$, due to the way the proofs are constructed, would have
    included all the blocks following $b$ of that level. Hence, all the blocks
    of the honest chain following $b$ of level $\mu$ have been included in the
    proof $\overline{\Pi}_B$.

    Let $\chain'_A$ be the adversarial $\mu$-level superchain after block $b$
    and $\chain'_B$ be the honest party's $\mu$-level superchain after block
    $b$.  These two chains will be disjoint since $b$ is defined as the LCA.

    We will now show that $\chain'_A[k_1 + 1:]$ contains no honestly mined
    blocks. By contradiction, assume that the block $\chain'_A[i]$ for some $i
    > k_1 + 1$ was honestly generated. But this means that an honest party had
    adopted the chain $\chain'_A[i - 1]$ at some round $r_2 \leq r_3$. Because
    of the way the honest parties adopt chains, this means that the superchain
    $\chain'_A[:i - 1]$ has an underlying properly constructed $0$-level chain
    $\chain_A$ which starts at genesis and includes all the blocks of the
    superchain $\chain'_A[:i - 1]$. Let $j$ be the index of block $b$ within
    $\chain_A$.  As $\chain_A$ contains at least all the blocks of the
    superchain $\chain'_A$, observe that $|\chain_A[j + 1:]| \geq i - 1 > k_1$.
    Therefore $\chain_A[:-k_1] \not\preccurlyeq \chain_B$. But, as $\chain_A$
    was adopted by an honest party at round $r_2$ which is prior to round $r_3$
    during which $\chain_B$ was adopted by an honest party, this contradicts
    the Common Prefix property of blockchains. It follows that with
    overwhelming probability in $k_1$, the $k_2 = m - k_1$ last blocks of the
    adversarial proof have been adversarially mined.

    Let $b'$ be the most recent honest block preceeding $b$, which could be the
    genesis block, and let $r_1$ be the round during which $b'$ was generated.
    We will consider the set of consecutive rounds $S$ starting at round $r_1$
    and ending at round $r_3$. We are considering a superchain of level $\mu$
    which has at least $m$ blocks, and hence the random oracle must have
    answered at least $m$ queries with a value $v < 2^{-\mu}T$ during $S$. From
    the assumption that the execution is typical, it follows that $Z^\mu(S)$
    and $X^\mu(S)$ are distributed close to their respective means. But the
    probability that the adversary is able to produce $k_2$ $\mu$-level blocks
    after block $b'$ faster than the honest parties are able to produce $m$
    $\mu$-level blocks after block $b'$ is negligible.
\end{proof}
