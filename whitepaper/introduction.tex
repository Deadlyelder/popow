\section{Introduction}

Bitcoin \cite{bitcoin} is the first decentralized currency. Several
cryptocurrencies have surfaced since, many of which use different consensus
rules. Such different proposals for consensus rules must necessarily be
implemented either as an altcoin or a hard-fork. Pegged sidechains provide an
alternative: While consensus rules can be different across blockchains, it is
useful to have one unit of value which can be moved between various
blockchains. This allows for consensus rules innovation and experimentation.

In the simplest version of sidechains, the nodes participating in the consensus
protocol must all maintain the different blockchains. This is not efficient and
adoption will be hindered. The solution for this is to provide succinct
stand-alone proofs that the winning chain of a block tree is a particular one.
These succinct proofs prove that proof-of-work took place without presenting
the actual proof-of-work. Succinctness requires that these proofs are
significantly shorter than presenting the whole chain. Technically, if the
claimed winning blockchain has a length of $|\chain|$ blocks, we want the
succinct proofs to have a size of $O(polylg|\chain|)$. These short proofs can
then be subsequently included in sidechain blocks where funds are locked in one
blockchain so that they can become available in another. This is in vast
improvement as compared to SPV proofs which are $O(|\chain|)$.

Proofs-of-proofs-of-work were explored in KLS (TODO: reference). These proofs
had the disadvantage of requiring interaction between a prover and a verifier,
making them unsuitable for sidechain adoption.

We extend these proofs to make them non-interactive, making them suitable for
sidechain use. We generalize the idea of proof-of-mining into not just being
able to talk about what the current winning chain suffix is, but allowing
provers and verifiers to prove more generic predicates. Such predicates can
express simple ideas, such as the inclusion of a transaction in the longest
chain, to complex ideas such as the modification of an account's balance over
time.

We work on the backbone model. We introduce two entities, the Prover and the
Verifier which work in the existing environment. The Prover is part of the
existing miner node which exists in the backbone protocol. The Verifier is a
completely new entity. When the game begins, the Prover and the Verifier are
instantiated with a fixed predicate $q$, which generalized the notion of
proof-of-mining and allows any blockchain property to be proven between the
Prover and the Verifier. Some of these predicates are more suitable for
succinct proofs than others. We focus our attention in what we call \textit{
reliable} predicates; that is, predicates which are monotonic and stable.
These predicates have the exceptional property that all honest miners share
their view of them in a way that is updated in a predictable manner, with a
decision that persists as the blockchain grows. Furthermore, we are interested
in \textit{succinct} predicates, predicates which can be proven using a
succinct protocol, a protocol which requires proofs that are short in terms of
the total blockchain size. Finally, we formalize the notion of
non-interactivity.

We use this model to explore which predicates are reliable and can be proven
succinctly.
