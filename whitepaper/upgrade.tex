\section{Upgrading the consensus layer}

\subsection{Soft fork}

Our construction requires an upgrade to the bitcoin consensus layer. In this
section we outline a possible upgrade path for the bitcoin network. The obvious
path forward for implementing our construction requires building an altcoin or
a hard fork for the new construction. This is the path implied in
\cite{KLS}.

Nevertheless, it is not hard to see that an existing coin such as bitcoin can
be upgraded to work with the new consensus rules using a soft fork.  Such a
construction in practice would require including the interlink data structure
not in the block header, but in the data of the coinbase transaction.  Clearly
it is enough to store a single hash of the whole interlink structure in the
coinbase data. The only requirement for the PoPoWs to work is that the
PoW commits to all the pointers within interlink so that the adversary cannot
cause a chain reorganization except with negligible probability. That way, each
superchain is really a chain which goes all the way back to genesis. If we take
that route, then each PoPoW will be required to present not only the block
header, but also a proof-of-inclusion path within the Merkle tree of
transactions proving that the coinbase transaction is indeed part of the block.
Once that is established, the coinbase data can be presented, and the verifier
will thereby know that the hash of the interlink data structure is correct.
Given the fact that in the current bitcoin implementation there is a fixed
limit for block sizes, we observe that including such proofs-of-inclusion will
only increase the PoPoW sizes by a constant factor per block, allowing for the
communication complexity to remain at $\Theta(polylog(|\chain|))$.

We now discuss the exact manner in which the interlink data structure should be
hashed to provide a single hash within the coinbase transaction. In \cite{KLS},
they propose the use of a Merkle tree to hash the interlink data structure.
However, no further discussion is made in this regard. Observe that NIPoPoWs
form a single chain of various levels which can skip certain blocks. However,
it does not form a tree. Therefore, for each block included in the proof, only
a single pointer needs to be presented to convince the Verifier. Near genesis,
the pointers that need to be included correspond to high levels; while near the
most recently generated block, the pointers correspond to low levels. One
important observation is this: In the formal construction of the proof, the
highest level superchain with at least $m$ blocks is included, and assume it is
of level $\mu$. The next level superchain, $\mu - 1$ is completely included and
has an expected number of $2m$ blocks. But note that since all $\mu$-level
superblocks are also $(\mu - 1)$-level superblocks, only the $\mu - 1$ level
needs to be in fact included. Among the expected $2m$ blocks of level $\mu -
1$, the last $m$ will need to be supported by level $\mu - 2$. Using the same
argument, since $(\mu - 1)$-level superblocks are also $(\mu - 2)$ level
superblocks, in expectation only $m$ blocks need to be included in level $\mu
- 1$. The argument continues inductively, until an expected number of $2m$
blocks needs to be included at level $0$ immediately before the $\chi$ suffix.
This gives us an exact estimation on the size of the proof: The proof will
contain exactly $m (\log(|\chain|) - \log(m))$ blocks in expectation, $m$ at each of
the $\mu - 1$ levels and $2m$ at level $0$.

By organizing the interlink pointers into a Merkle tree of $\log(|\chain|)$
items, a proof-of-inclusion in the pointers Merkle tree can be provided in
$\log \log(|\chain|)$ space, noting that the $0$-level pointer need not be
included in this Merkle tree, but the genesis block needs to be. Then the root
of the pointers Merkle tree can be proved to have been included in the block
header in $\log(|\overline x|)$ using the standard Merkle tree of transactions,
where $\overline x$ is the vector of all transactions in the given block. This
makes the proof size require $\log(|\overline x|) + \log\log(|\chain|)$ hashes per
block for a total of $m (\log(|\chain|) - \log(m))(\log(|\overline x|) +
\log\log(|\chain|)$ hashes. In addition, $m (\log(|\chain|) - \log(m))$ block headers
and coinbase transactions are needed. More concretely, given that currently
$|\chain| = 464,185$, we have that $\log(|\chain|) = 18$ and $\log\log(|\chain|) =
5$.  Typically, $|\overline x| = 2000$ in the current bitcoin setting, which
makes $\log(|\overline x|) = 11$. For the $k$-suffix, only $k$ block headers need
to be included. We set $k = 6$ as is traditional in the bitcoin setting and see
that block headers are $80$ bytes and hash outputs are $32$ bytes. However, we
note that block headers do not need to include the previous block header hash
for the $k$-suffix, as each previous block header hash can be calculated by the
Verifier, limiting header sizes to $48$ bytes for the $k$ last blocks.
Furthermore, the $k$-suffix does not require the presentation of the coinbase
transaction data. These are also true for the $2m$ blocks in $\overline \Pi[0]$.
Note also that for the proof prefix $\overline \Pi$, the coinbase transaction
hash need not be included: It can be evaluated by the Verifier when building
the Merkle tree during the proof-of-inclusion. Similarly, the root of the
pointers Merkle tree can be omitted from the coinbase transaction data when
transmitting the proof. Additionally, the leaf of the pointers Merkle tree can
also be omitted, as it can be obtained by the Verifier by simply hashing the
previous block in the proof. In fact, no block ids need to be transmitted at
all, as they can all be built from the Verifier starting from the knowledge of
Genesis.

Based on these observations, we provide an estimate for proof sizes of our
scheme for various parameterizations of $m$ in Table~\ref{table.size}.

\begin{table}
  \caption{\label{table.size}
    Estimated size of NIPoPoWs for various values of the security parameter $m$
    setting $k = 6$ and with current values for transaction count, block count,
    coinbase size and hash output length.}
  \begin{tabular}{llll}
      {\bf m}  & {\bf NIPoPoW size (KB)} & {\bf \# of blocks} & {\bf
      \# of hashes}\\
      $6$   & $70$  & $108$ & $1440$  \\
      $15$  & $146$ & $231$ & $2925$  \\
      $30$  & $270$ & $426$ & $5400$  \\
      $50$  & $412$ & $656$ & $8250$ \\
      $100$ & $750$ & $1206$ & $15000$ \\
      $127$ & $952$ & $1530$ & $19050$ \\
  \end{tabular}
\end{table}

\subsection{Velvet fork}

Now that the consensus layer details have been presented, we move on to
illustrate that, in fact, no fork is needed. Given that intuitively these
changes constitute rule modifications to the consensus layer, we call this
technique a \textit{velvet fork}.

The way to achieve this is by requiring upgraded miners to include the
interlink data structure in the form of a Merkle chain root hash in their
coinbase data, similar to a soft fork. An unupgraded miner will as usual ignore
this data as comments. However, we further require the upgraded miners to
accept all previously accepted blocks, regardless of whether they have included
the interlink data structure or not. In fact, even if the interlink data
structure is included and contains invalid data, we require the upgraded miners
to accept their containing blocks. Malformed interlink data could be simply of
the wrong format, for example higher-level points appearing lower in the Merkle
chain, or the pointers could be pointing to superblocks of incorrect
levels. Furthermore, the pointers could be pointing to superblocks of the
correct level, but not to the most recent block. By requiring upgraded miners
to accept all such blocks, we do not modify the set of accepted blocks:
Upgraded and unupgraded miners accept the exact same set of blocks. Therefore,
the upgrade is simply a ``recommendation'' for miners and not an actual change in
the consensus rules.

The reason this can work is because provers and verifiers of our protocol can
check the validity of the claims of miners who make false interlink chain
claims. An upgraded Prover can check whether a block contains correct interlink
data and use it. If a block does not contain correct interlink data, the Prover
can opt not to use those pointers at all in their proofs. As the Verifier
verifies all claims of the Prover, adversarial miners cannot cause harm by
including invalid interlink data. The only thing that the Verifier cannot
verify in terms of interlink claims is whether the claimed superblock of a
given level is in fact the most recent previous superblock of that level.
However, an adversarial Prover cannot make use of that to construct winning
proofs, as they are only able to present shorter chains in that case. The
honest Prover can simply ignore such pointers as if they were not included at
all.

The velvet Prover is shown in Algorithm~\ref{alg.backbone-velvet-prover}. The
Prover works as usual, but additionally mantains a realLink data structure
which stores the correct interlink for each block. Whenever a new winning chain
is received from the network, the Prover checks it for blocks that it hasn't
seen before. For those blocks, it maintains its own realLink data structure
which it updates accordingly to make sure it is correct regardless of what the
interlink data structure of the received block claims.

\import{./}{algorithms/alg.backbone-velvet-prover.tex}
\import{./}{algorithms/alg.nipopow-velvet-innerchain.tex}
\import{./}{algorithms/alg.nipopow-velvet-follow.tex}
\import{./}{algorithms/alg.nipopow-velvet-prover.tex}
