#include <cstdlib>
#include <iostream>
#include <ctime>
#include <vector>
#include <cmath>
#include <random>
#include <iomanip>
#include <fstream>
#include <cassert>
#include <string>

using namespace std;

// GKL constants
const int n = 100; // number of total parties
const int t = 45; // number of malicious parties
const int KAPPA = 22; // number of bits in hash function
const int MAX_BLOCK_ID = 1 << KAPPA; // block id unattainable upper bound
const int T = 8192; // mining target
const int q = 1; // queries allowed per player per round

// KLS constants
const int m = 10; // minimum number of blocks for valid superchain
const int MU = 5; // level of attack

// Simulation constants
const int NUM_ROUNDS = 1000;
const int MONTE_CARLO_ROUNDS = 1;
const bool OUTPUT_GRAPH = true;

template<typename T>
void concat(vector<T>& target, const vector<T>& source) {
    target.insert(
        end(target),
        begin(source),
        end(source)
    );
}

int highest_one_bit(int val) {
    int ret = 0;

    while (val >>= 1) {
        ++ret;
    }
    return ret;
}

int get_level(int id) {
    static int log_T = highest_one_bit(T);
    int level = log_T - highest_one_bit(id) - 1;
    // cout << "Level of " << id << " is " << level << endl;
    return level;
}

int random_oracle(int nonce, int h) {
    static random_device rand_dev;
    mt19937 generator(rand_dev());
    uniform_int_distribution<int> distribution(0, MAX_BLOCK_ID - 1);

    return distribution(generator);
}

template<typename T>
class GarbageCollector {
public:
    vector<T*> objs;

    void add(T* obj) {
        objs.push_back(obj);
    }
    void cleanup() {
        for (auto obj: objs) {
            delete obj;
        }
        objs.clear();
    }
};

class Block {
private:
    int x;

public:
    Block* parent;
    int id;
    // size of the blockchain this block is the tip of
    int height;
    // superblock level
    int level;
    // whether this block was generated by an adversary
    bool adversarial = false;
    // whether this block belongs to the secret chain
    bool secret = false;

    Block(Block* parent, int x, int id) {
        this->parent = parent;
        this->x = x;
        this->id = id;
        if (parent == NULL) {
            // genesis
            this->height = 0;
        }
        else {
            this->height = parent->height + 1;
        }
        level = get_level(id);
    }

    bool is_genesis() {
        return this->parent == NULL;
    }

    template<typename T, typename Func>
    int fold(Func cb, T accumulator) {
        Block* tip = this;

        while (tip != NULL) {
            accumulator = cb(tip, accumulator);
            tip = tip->parent;
        }

        return accumulator;
    }
};

class BlockTree {
public:
    vector<Block*> blocks;

    void add(Block* block) {
        blocks.push_back(block);
    }
    void cleanup() {
        blocks.clear();
    }
    void draw(string filename) {
        fstream graph;

        graph.open(filename, fstream::out);
        graph << "digraph {" << endl;
        for (auto block: blocks) {
            if (block->adversarial && !block->secret) {
                graph
                    << "_" << block
                    << " [fillcolor=coral, style=\"filled\"]" << endl;
            }
            else if (block->level >= MU) {
                graph
                    << "_" << block
                    << " [fillcolor=blueviolet, style=\"filled\"]" << endl;
            }
            graph << "_" << block << " -> _" << block->parent << endl;
        }
        graph << "}" << endl;
    }
};


GarbageCollector<Block> gc;

class Player {
protected:
    Block* genesis;
    // number of queries available to the player
    int q;

    void diffuse(Block* block) {
        // cout << "Broadcasting newly discovered block" << endl;
        diffused.push_back(block);
    }
    int G(int s, int x) {
        return 0;
    }
    Block* max_valid(Block* prev_tip, const vector<Block*>& receive) {
        Block* ret = prev_tip;

        for (auto block: receive) {
            if ((block->height > prev_tip->height) ||
                (block->height == prev_tip->height && block->adversarial)) {
                // cout
                //     << "Adopting new blockchain of height "
                //     << block->height
                //     << " (with tip " << block->id << ")"
                //     << endl;
                ret = block;
            }
        }
        if (ret != prev_tip) {
            return ret;
        }
        return NULL;
    }
    Block* pow(int x, Block* tip) {
        int ctr = 1;

        int s = tip->id;
        int h = G(s, x);

        while (ctr <= q) {
            int candidate_block_id = random_oracle(ctr, h);

            if (candidate_block_id <= T) {
                Block* ret = new Block(tip, x, candidate_block_id);
                gc.add(ret);

                // found a block
                /*
                if (adversarial) {
                    cout << "Adversary";
                }
                else {
                    cout << "An honest party";
                }
                cout
                    << " found a block: "
                    << ret->id
                    << " (at level "
                    << ret->level
                    << ")"
                    << endl;
                */

                return ret;
            }
            ++ctr;
        }
        // failed to find a block
        return NULL;
    }
public:
    vector<Block*> diffused;

    void clear_diffusion_tape() {
        diffused = vector<Block*>();
    }
};

class HonestParty: public Player {
private:
    Block* honest_tip;

public:
    HonestParty(Block* genesis, int q) {
        this->q = q;
        this->genesis = genesis;
        honest_tip = genesis;
    }
    Block* read() {
        return honest_tip;
    }
    void invoke(int round, vector<Block*> receive) {
        Block* new_tip = max_valid(honest_tip, receive);

        if (new_tip != NULL) {
            honest_tip = new_tip;
        }

        Block* mined = pow(0, honest_tip);
        if (mined != NULL) {
            // cout << "Honest party mined a block of depth " << mined->height << endl;
            honest_tip = mined;
            diffuse(mined);
        }
    }
};

class Adversary: public Player {
private:
    Block* honest_tip;
    Block* adversarial_tip;
    // level of attack
    int mu = MU;

public:
    Adversary(Block* genesis, int q) {
        this->q = q;
        this->genesis = genesis;
        honest_tip = genesis;
        adversarial_tip = genesis;
    }
    Block* read() {
        return adversarial_tip;
    }
    Block* pow(int x, Block* tip) {
        Block* fresh = Player::pow(x, tip);

        if (fresh != NULL) {
            fresh->adversarial = true;
        }

        return fresh;
    }
    void invoke(
        int round,
        const vector<Block*>& receive,
        vector<Block*>& rushing_adversary_tape
    ) {
        // cout << "Honest tip: " << honest_tip << endl;
        // cout << "Genesis: " << genesis << endl;

        Block* new_tip = max_valid(honest_tip, receive);

        if (new_tip != NULL) {
            /*
            cout
                << "New honest chain of length "
                << honest_tip->height + 1
                << " with tip "
                << honest_tip->id
                << endl;
            */
            honest_tip = new_tip;
            /*
            if (honest_tip->level >= mu && honest_tip->height > 0) {
                cout << "Adversary detected bad superquality tip" << endl;
            }
            */
        }

        if (honest_tip->level < mu || honest_tip->height == 0) {
            // adversarial strategy #1
            // mine on adversarial chain
            Block* mined = pow(0, adversarial_tip);
            if (mined != NULL) {
                // cout << "Adversary mined block on top of adversarial chain" << endl;
                mined->secret = true;
                diffuse(mined);
                adversarial_tip = mined;
            }
        }
        else {
            // cout << "Bad superquality" << endl;
            // adversarial strategy #2
            // mine on honest chain trying to harm superquality
            Block* mined = pow(0, honest_tip->parent);
            if (mined != NULL) {
                // cout
                //     << "Adversary successfully supressed honest "
                //     << mu
                //     << "-superblock"
                //     << endl;
                diffuse(mined);
                honest_tip = mined;
            }
        }
    }
};

int main() {
    cout
        << "== Simulation Parameters =="
        << endl
        << "Monte Carlo rounds: " << MONTE_CARLO_ROUNDS
        << endl
        << "Backbone rounds per Monte Carlo round: " << NUM_ROUNDS
        << endl
        << "n = " << n << endl
        << "t = " << t << endl
        << "q = " << q << endl
        << "2^kappa = " << MAX_BLOCK_ID << endl
        << "T = " << T << endl
        << "mu = " << MU << endl
        << "m = " << m << endl;

    int count_adversary_chain_longer = 0;
    int count_adversary_superchain_longer = 0;

    srand(time(NULL));

    for (size_t repeat = 0; repeat < MONTE_CARLO_ROUNDS; ++repeat) {
        Block* genesis = new Block(NULL, 0, 0);
        gc.add(genesis);
        Adversary adversary = Adversary(genesis, t * q);
        vector<HonestParty> honest;
        vector<Block*> old_broadcast_tape;
        vector<Block*> new_broadcast_tape;
        BlockTree bt;

        for (size_t i = 0; i < n - t; ++i) {
            honest.push_back(HonestParty(genesis, q));
        }

        for (size_t round = 1; round <= NUM_ROUNDS; round++) {
            // cout << "== Round " << round << " ==" << endl;
            new_broadcast_tape = vector<Block*>();
            for (size_t i = 0; i < n - t; i++) {
                honest[i].invoke(round, old_broadcast_tape);
                for (auto block: honest[i].diffused) {
                    bt.add(block);
                }
                concat(new_broadcast_tape, honest[i].diffused);

                honest[i].clear_diffusion_tape();
            }
            /*
            int num_honest_blocks = new_broadcast_tape.size();
            if (num_honest_blocks == 1) {
                cout << "Uniquely successful round" << endl;
            }
            else if (num_honest_blocks > 1) {
                cout << "Successful round" << endl;
            }
            */
            adversary.invoke(round, old_broadcast_tape, new_broadcast_tape);
            for (auto block: adversary.diffused) {
                bt.add(block);
            }
            concat(new_broadcast_tape, adversary.diffused);
            /*
            if (new_broadcast_tape.empty()) {
                cout << "Silent round" << endl;
            }
            */
            adversary.clear_diffusion_tape();
            old_broadcast_tape = new_broadcast_tape;
        }
        Block* adversarial_chain = adversary.read();
        Block* honest_chain = honest[0].read();

        auto count_superblocks = [](Block* b, int length) {
            if (b->level >= MU && !b->is_genesis()) {
                return length + 1;
            }
            return length;
        };

        int adversarial_superchain_length = adversarial_chain->fold(
            count_superblocks, 0
        );
        int honest_superchain_length = honest_chain->fold(
            count_superblocks, 0
        );
        if (adversarial_chain->height > honest_chain->height) {
            ++count_adversary_chain_longer;
        }
        if (adversarial_superchain_length > honest_superchain_length
         && adversarial_superchain_length >= m) {
            ++count_adversary_superchain_longer;
        }
        cout
            << "== Summary =="
            << endl
            // << "Tip of adversarial blockchain: "
            // << adversarial_chain->id
            // << endl
            << "Adversarial chain length: "
            << adversarial_chain->height + 1
            << endl
            << "Adversarial superchain length: "
            << adversarial_superchain_length
            << endl
            // << "Tip of honest blockchain: "
            // << honest_chain->id
            // << endl
            << "Honest chain length: "
            << honest_chain->height + 1
            << endl
            << "Honest superchain length: "
            << honest_superchain_length
            << endl;
        if (OUTPUT_GRAPH) {
            assert(MONTE_CARLO_ROUNDS == 1);
            bt.draw("simulation.dot");
        }

        gc.cleanup();
    }
    cout
        << setprecision(6)
        << "== Monte Carlo Simulation Statistics =="
        << endl
        << "Pr[adv chain longer] = "
        << float(count_adversary_chain_longer) / MONTE_CARLO_ROUNDS
        << endl
        << "Pr[adv superchain longer] = "
        << float(count_adversary_superchain_longer) / MONTE_CARLO_ROUNDS
        << endl;

    return 0;
}
